# -*- coding: utf-8 -*-
"""Uniforme_discreta: Lanzamiento_de_dados.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G3RNom9yhOa8_BWrmvFkE3T7yqMBe0jB

#Lanzamiento de dos dados

## Diccionarios

$$\{\text{key}:\text{values}\}.$$
"""

d = {"César": ["Masha", "Mila", "Sneg"],
     "Julio": [3, 10, 12],
     "Gal": [7.0, 5.0, 6.0]}

type(d)

d.keys() # Son las llaves de un diccionario

d.values()

d.items()

"""## Se lanzan dos dados justos

- $\Omega = \{1,2,3,4,5,6\}\times \{1,2,3,4,5,6 \}$.
- $\mathcal{F}=p(\Omega)$.
- Para $\omega=(i,j)$ donde $i, j=1,\dots, 6$
$$\mathbb{P}(\{\omega\})=\frac{1}{36}.$$

-----

## Vamos a definir a la siguiente variable aleatoria
$S$ es la variable aleatoria que cuenta la suma de las caras de los dados.

$$S:\Omega \to R_{S}=\{2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 \}$$

Para entender a la ley de la variable aleatoria, basta con entender a los siguientes datos:
$$\{(k, \mathbb{P}(S=k)) \}_{k\in R_{S}}.$$

Veamos a $S$ como eventos. Sea $S_{n}$ el evento la suma de las caras es $n$.
"""

#itertools proporciona funciones que crean iteradores eficientes y rápidos
#product toma 2 o más iterables y duvuelve su producto cartesiano
from itertools import product

#Fractions proporciona soporte para cálculos con números racionales
#Fraction se usa para crear fracciones a partir de número enteros, flotantes, cadenas, etc.
from fractions import Fraction

#Calcular la probabilidad P de un evento A dado un espacio muestral Omega.
# A sería el evento, por ejemplo obtener una suma específica al lanzar 2 dados, como obtener un 7
#Omega es el espacio muestral de todos los posibles resultados
#len(A) es la cantidad de resultados en el evento A
#len(Omega) es la cantidad total de resultados posibles en el espacio muestral

def P(A, Omega):
  P = Fraction(len(A), len(Omega) )
  return P

"""$$S_{n}=\{(i,j)\in \Omega : i+j =n \}$$"""

S_2 = {(i,j) for i in range(1,7) for j in range(1,7) if i+j == 2 }
S_2

#Se crean las posibles combinaciones de resultados al lanzar 2 dados
L = [i for i in range(1,7)]

Omega = set(product(L, repeat =2 ))
Omega

#Se crea un diccionario con las posibles combinaciones al lanzar 2 dados y la suma correspondiente de esos resultados
S = {(i,j): i+j for i,j in Omega}

S

#Se crea un diccionario que utiliza conjuntos como valores y proporciona un conjunto vacío como valor predeterminado para cada clave que aún no esté en el diccionario
from collections import defaultdict

dS = defaultdict(set)
dS

#Este bucle recorre todas las claves y valores en el diccionario "S"
#y organiza las claves en conjuntos dentro del diccionario "dS", según el valor asociado en el diccionario "S"
for l, v in S.items():
    dS[v].add(l)

dS

#Proporciona las probabilidades de cada valor obtenido en el espacio muestral omega, según el diccionario dS
leyS = {k : P(A,Omega) for k , A in dS.items() }
leyS

"""## Introducción a pandas."""

import pandas as pd

#Se crea un objeto Series a partir del diccionario "LeyS"
#Este código convierte el diccionario en una serie y luego ordena los índices de la serie
leyS = pd.Series(leyS)
leyS = leyS.sort_index()

leyS

"""## Ejercicios
1.- Documenta tu colab.

2.- Calcula la ley de las siguientes variables aleatorias:

    - La diferencia de las caras sea mayor que $1$.

    - La suma de las caras sea par.

3.- Verifica, en cada caso, que $$\sum_{k\in R_{X}}\mathbb{P}(X=x)=1.$$

4.- Sube tu notebook a tu GitHub.

## Respuesta

###1. La diferencia de las caras sea mayor que 1

*   Vamos a definir el espacio muestral

 $\Omega = \{1,2,3,4,5,6\}\times \{1,2,3,4,5,6 \}$.

 $\mathcal{F}=p(\Omega)$.

 Para $\omega=(i,j)$ donde $i, j=1,\dots, 6$

 $$\mathbb{P}(\{\omega\})=\frac{1}{36}.$$
"""

from itertools import product
from fractions import Fraction

def P(A, Omega):
  P = Fraction(len(A), len(Omega) )
  return P

# Definir el espacio muestral
L = [i for i in range(1, 7)]
Omega = set(product(L, repeat=2))
Omega

#Se crea un diccionario con las posibles combinaciones al lanzar 2 dados y la diferencia correspondiente de esos resultados
G = {(i,j): i-j for i,j in Omega}
G

#Se crea un diccionario que utiliza conjuntos como valores y proporciona un conjunto vacío como valor predeterminado para cada clave que aún no esté en el diccionario
from collections import defaultdict

dG = defaultdict(set)
dG

#Este bucle recorre todas las claves y valores en el diccionario "G"
#y organiza las claves en conjuntos dentro del diccionario "dG", según el valor asociado en el diccionario "G"
for l, v in G.items():
    dG[v].add(l)

dG

#Proporciona las probabilidades de cada valor obtenido en el espacio muestral omega, según el diccionario dS
leyG = {k : P(A,Omega) for k , A in dG.items() }
leyG

import pandas as pd

leyG = pd.Series(leyG)
leyG = leyG.sort_index()

leyG

#Calculamos la probabilidad de que la diferencia sea mayor que 1

sum_mayor1 = sum(leyG[leyG.index > 1])

print('La probabilidad de que la diferencia sea mayor que 1 es de:', sum_mayor1)

#Verificamos que la suma de todas las probabilidades sea igual 1

sum_probabilidades = sum(leyG)

print('La suma de todas las probabilidades es igual a:', sum_probabilidades)

"""##2. La suma de las caras sea par


"""

#Se crea un diccionario con las posibles combinaciones al lanzar 2 dados y la suma correspondiente de esos resultados
B = {(i,j): i+j for i,j in Omega}
B

#Se crea un diccionario que utiliza conjuntos como valores y proporciona un conjunto vacío como valor predeterminado para cada clave que aún no esté en el diccionario
from collections import defaultdict

dB = defaultdict(set)
dB

#Este bucle recorre todas las claves y valores en el diccionario "G"
#y organiza las claves en conjuntos dentro del diccionario "dG", según el valor asociado en el diccionario "G"
for l, v in B.items():
    dB[v].add(l)

dB

#Proporciona las probabilidades de cada valor obtenido en el espacio muestral omega, según el diccionario dS
leyB = {k : P(A,Omega) for k , A in dB.items() }
leyB

leyB = pd.Series(leyB)
leyB = leyB.sort_index()

leyB

#Calculamos la probabilidad de que la suma de las caras sea par

sum_par = sum(leyB[leyB.index % 2 == 0])

print('La probabilidad de que la diferencia sea mayor que 1 es de:', sum_par)

#Verificamos que la suma de todas las probabilidades sea igual 1

sum_probabilidades2 = sum(leyB)

print('La suma de todas las probabilidades es igual a:', sum_probabilidades2)